/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
#warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

#include "../Src/Stm32_F103C6_Drivers/inc/Stm32_F103C6_gpio_driver.h"
#include "../Src/Stm32_F103C6_Drivers/inc/Stm32_F103C6_TIMER_driver.h"
#include "../Src/Stm32_F103C6_Drivers/inc/Stm32_F103C6_RCC_driver.h"
#include "../Src/Stm32_F103C6_Drivers/inc/Stm32_F103C6_USART_driver.h"


#include "../Src/HAL/UltraSonic_HC_SR04/UltraSonic_Interface.h"
#include "../Src/HAL/LCD/LCD_Interface.h"
#include "../Src/HAL/UltraSonic_HC_SR04/UltraSonic_Interface.h"

#include "../Src/HAL/includes/MPU6050.h"


#include "../Src/HAL/Stepper/Stepper.h"


#include "../Src/HAL/includes/DC_Motor.h"

#define TARGET_DISTANCE_MIN 2
#define TARGET_DISTANCE_MAX

uint8_t dataFromMPU6050[6];
float Accel_X_RAW = 0;
float Accel_Y_RAW = 0;
float Accel_Z_RAW = 0;


extern float AccErrorX, AccErrorY;
extern int GyroErrorX, GyroErrorY, GyroErrorZ;


float elapsedTime=0.015, currentTime, previousTime;

int16_t Gyro_X_RAW = 0;
int16_t Gyro_Y_RAW = 0;
int16_t Gyro_Z_RAW = 0;
float GyroX,GyroY,GyroZ;


float accAngleX, accAngleY, gyroAngleX, gyroAngleY, gyroAngleZ,yaw,roll,pitch;

uint8_t Data = 0;

char buffer[5];

float Kp = 0.5; 	// Proportional gain
float Ki = 0.001; 	// Integral gain
float Kd = 0.05; 	// Derivative gain


int main(void) {
	MCAL_RCC_CLK_Init(HSE_CLK, RCC_CLK_72M);

	RCC_GPIOC_CLK_EN();
	RCC_USART1_CLK_EN();

	RCC_GPIOB_CLK_EN();
	RCC_GPIOA_CLK_EN();

	RCC_AFIO_CLK_EN();
	RCC_TIMER3_CLK_EN();
	RCC_I2C1_CLK_EN();





	UART_Config UART_Cfg;
	UART_Cfg.BaudRate = UART_BaudRate_9600;
	UART_Cfg.HWFlowCtrl = UART_HWFlowCtrl_NONE;
	UART_Cfg.IRQ_Enable = UART_IRQ_Enable_NONE;
	UART_Cfg.P_IRQ_CallBack = NULL;
	UART_Cfg.Parity = UART_Parity_NONE;
	UART_Cfg.Payload_length = UART_Payload_Length_8B;
	UART_Cfg.StopBits = UART_StopBits_1;
	UART_Cfg.USART_Mode = UART_Mode_Tx_Rx;

	MCAL_UART_Init(USART1, &UART_Cfg);
	// PA9 --> Tx
	// PA10 --> Rx
	MCAL_UART_GPIO_SetPins(USART1);

	TIMER3_Init(RCC_CLK_36M);


	MPU6050_Init();
	MPU6050_CalculateError();



	while (1) {

		// Init Acceleration
		Data = 0x00;
		MPU6050_Write(PWR_MGMT_1, &Data, 1);

		Data = 0x05;
		MPU6050_Write(CONFIG, &Data, 1);

		Data = 0x10;
		MPU6050_Write(ACCEL_CONFIG, &Data, 1);


		// Acceleration Measurements
		// 2 Â±8g 4096 LSB/g
		// Read 6 Registers from ACCEL_XOUT_H till ACCEL_ZOUT_L
		MPU6050_Read(ACCEL_XOUT_H, dataFromMPU6050, 6);
		Accel_X_RAW = ((int16_t)((dataFromMPU6050[0] << 8) | (dataFromMPU6050[1]))) / 4096.0;
		Accel_Y_RAW = ((int16_t)((dataFromMPU6050[2] << 8) | (dataFromMPU6050[3]))) / 4096.0;
		Accel_Z_RAW = ((int16_t)((dataFromMPU6050[4] << 8) | (dataFromMPU6050[5]))) / 4096.0;

		accAngleX = (atan(Accel_Y_RAW / sqrt(pow(Accel_X_RAW, 2) + pow(Accel_Z_RAW, 2))) * 180 / 3.14) - 0.58; // AccErrorX ~(0.58)
		accAngleY = (atan(-1 * Accel_X_RAW / sqrt(pow(Accel_Y_RAW, 2) + pow(Accel_Z_RAW, 2))) * 180 / 3.14) + 1.58; // AccErrorY ~(-1.58)

		// Init Gyroscope
		Data = 0x08;
		MPU6050_Write(GYRO_CONFIG, &Data, 1);


		// Gyroscope Measurements
		MPU6050_Read(GYRO_XOUT_H, dataFromMPU6050, 6);
		Gyro_X_RAW = (int16_t)(dataFromMPU6050[0] << 8 | dataFromMPU6050 [1]);
		Gyro_Y_RAW = (int16_t)(dataFromMPU6050[2] << 8 | dataFromMPU6050 [3]);
		Gyro_Z_RAW = (int16_t)(dataFromMPU6050[4] << 8 | dataFromMPU6050 [5]);
		// Correct the outputs with the calculated error values
		GyroX = (Gyro_X_RAW / 65.5) - GyroErrorX; // GyroErrorX ~(-0.56)
		GyroY = (Gyro_Y_RAW / 65.5) - GyroErrorY; // GyroErrorY ~(2)
		GyroZ = (Gyro_Z_RAW / 65.5) - GyroErrorZ; // GyroErrorZ ~ (-0.8)

		// Currently the raw values are in degrees per seconds, deg/s, so we need to multiply by seconds (s) to get the angle in degrees
		// Calculate elapsed time with seconds
		elapsedTime = Get_TIMER3_Counter();
		elapsedTime /= 1000000;

		TIMER3_Stop();

		gyroAngleX = gyroAngleX + (GyroX * elapsedTime);
		gyroAngleY = gyroAngleY + (GyroY * elapsedTime);
		yaw = yaw + (GyroZ * elapsedTime);


		TIMER3_Start();


		roll = 0.96 * gyroAngleX + 0.04 * accAngleX;
		pitch = 0.96 * gyroAngleY + 0.04 * accAngleY;


		MCAL_UART_SendString(USART1, "Roll: ", Enable);
		sprintf(buffer, "%d\n", (int)roll);
		MCAL_UART_SendString(USART1, buffer, Enable);

		MCAL_UART_SendString(USART1, "Pitch: ", Enable);
		sprintf(buffer, "%d\n", (int)pitch);
		MCAL_UART_SendString(USART1, buffer, Enable);

		MCAL_UART_SendString(USART1, "Yaw: ", Enable);
		sprintf(buffer, "%d\n", (int)roll);
		MCAL_UART_SendString(USART1, buffer, Enable);






	}

}

